#pragma once

#include <SpheresEngine/InputEngine/UserId.h>
#include <SpheresEngine/VectorTypes.h>

#include <vector>

/**
 * This class contains one input event, like a key press ore a mouse movement
 */
class Input {
public:

	/**
	 * The device this input stems from
	 */
	enum class Device {
		Unknown, Keyboard, Mouse, VrHeadset,
		/**
		 * a magic wand type input device, like the Google Daydream Controller
		 */
		MagicWand
	};

	/**
	 * The type of the input
	 */
	enum class Type {
		/*
		 * The default
		 */
		NotSet,

		Direction, ButtonDown, ButtonUp,
		/**
		 * The head pose input from VR or AR devices
		 */
		HeadPose,
		/**
		 * Orientation, for example of a magic wand
		 */
		Orientation
	};

	/**
	 * If input type is button, this enum specifies which button has been pressed
	 */
	enum class ButtonType {
		Unknown, /* the button is not mapped to a known enum */
		Touchpad, /* on MagicWand Devices, the touchpad has been pressed down */
		Escape, /* escape button */
		Left, Right, Up, Down /* digital direction keys */
	};

	/**
	 * Create a Input object which hold the direction input of one device
	 */
	static Input createDirection(Device dev, Vector2 dir) {
		return Input(dev, Type::Direction, ButtonType::Unknown, dir);
	}

	/**
	 * Create a Input object which stores the orientation of a magic-wand style object
	 */
	static Input createOrientation(Quaternion quat) {
		return Input(Device::MagicWand, quat);
	}

	/**
	 * Create a Input object which hold the button down input for a device and one button
	 */
	static Input createButtonDown(Device dev, ButtonType btn) {
		return Input(dev, Type::ButtonDown, btn);
	}

	/**
	 * Create a Input object which hold the button up input for a device and one button
	 */
	static Input createButtonUp(Device dev, ButtonType btn) {
		return Input(dev, Type::ButtonUp, btn);
	}

	static Input createMouseMove(Vector2 relativeMovement) {
		return Input(Device::Mouse, Type::Direction, relativeMovement);
	}

	/**
	 * Return the type of this input
	 */
	Type type() const {
		return m_type;
	}

	/**
	 * Return the direction stored in this input
	 */
	Vector2 direction() const {
		assert(type() == Type::Direction);
		return m_direction;
	}

	/**
	 * Return the orientation of this input
	 */
	Quaternion orientation() const {
		assert(type() == Type::Orientation);
		return m_orientation;
	}

	/**
	 * Return the button type of this input
	 */
	ButtonType buttonType() const {
		return m_buttonType;
	}

	/**
	 * Return the devices this input was generated by
	 */
	Device device() const {
		return m_device;
	}

private:

	/**
	 * Create an Input object which stores an orientation input
	 * type for one device
	 */
	Input(Device dev, Quaternion quat) {
		m_device = dev;
		m_type = Type::Orientation;
		m_orientation = quat;
	}

	/**
	 * Create an Input object and set the device and type value
	 */
	Input(Device dev, Type type, ButtonType buttonType = ButtonType::Unknown,
			Vector2 dir = Vector2::Zero()) :
			m_device(dev), m_type(type), m_buttonType(buttonType), m_direction(
					dir) {

	}

	/**
	 * Create an Input object and set the device, the input type and the direction of the movement
	 */
	Input(Device dev, Type type, Vector2 dir) :
			m_device(dev), m_type(type), m_direction(dir) {

	}
	/**
	 * Store the type of this input class
	 */
	Type m_type = Type::NotSet;

	/**
	 * Store the button type. Will only be set, if the type is button-related
	 */
	ButtonType m_buttonType = ButtonType::Unknown;

	/**
	 * Store the input device which generated this input
	 */
	Device m_device;

	/**
	 * Store a 2 dimensional direction
	 */
	Vector2 m_direction;

	/**
	 * Orientation of the input, in case the input type is orientation like
	 */
	Quaternion m_orientation;

	/** unique identifier for the input element on the device itself
	 * with buttons, this can be the number of the button, with direction
	 * this can be the number of the analog stick.
	 * Not used yet.
	 */
	int m_inputElementIndifier = 0;

	/**
	 * the user or users which send this input. Not used yet, will be important
	 * as soon as more than one user needs to be supported
	 */
	std::vector<UserId> m_users;
};

